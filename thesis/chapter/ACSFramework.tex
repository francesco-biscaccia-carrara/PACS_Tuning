The Alternating Criteria Search (ACS) heuristic is designed to pursue a twofold objective: to identify a feasible solution and to subsequently enhance its quality with respect to the objective function $c^T x$. To this end, ACS employs a Large Neighborhood Search (LNS) strategy, which iteratively solves two auxiliary mixed-integer programming (MIP) subproblems in order to address both objectives.
The heuristic requires an initial vector, which is not mandated to be a feasible solution for the original MIP. As illustrated in Figure \ref{fig:ACS_heu_workflow}, this vector is iteratively refined by solving sub-MIPs, where a subset of variables is fixed to the values defined in the initial input.
\begin{figure}[h]
\centering
\resizebox{\columnwidth}{!}{
\begin{tikzpicture}[
    rect/.style={rectangle, draw=black, align=center, font=\footnotesize,fill=white},
    oval/.style={ellipse, draw=black, align=center, font=\footnotesize, fill=white},
    arrow/.style={->, >=Stealth},
    big-box/.style={rectangle, draw=black, dash pattern=on 5pt off 3pt,
                    inner sep=12pt, fill=gray!20, rounded corners=2pt},
    label/.style={font=\footnotesize\bfseries}
]

% ----------- Nodes (drawn first) -----------
% Initial Solution box
\node[rect] (initial) at (-3,0) {Initial\\Solution};

% Variable Fixing 1
\node[rect] (var-fix1) at (0,1) {Variable Fixing};

% Reduce Infeasibility
\node[oval] (reduce) at (2.5,0) {Reduce\\Infeasibility};

% Improved Feasible Solution
\node[rect] (improved-feas) at (6,0) {Improved\\Feasibility\\Solution};

% Variable Fixing 2
\node[rect] (var-fix2) at (9,1) {Variable Fixing};

% Minimize Objective
\node[oval] (minimize) at (11.5,0) {Minimize\\Objective};

% Improved Quality Solution
\node[rect] (improved-qual) at (15,0) {Improved\\Quality\\Solution};

% ----------- Background grouping boxes -----------
\begin{pgfonlayer}{background}
  \node[big-box, fit=(var-fix1)(reduce)] (infeas-box) {};
  \node[big-box, fit=(var-fix2)(minimize)] (obj-box) {};
\end{pgfonlayer}

% ----------- Labels (on top) -----------
\node[label, anchor=south west] at ([xshift=3pt]infeas-box.north west) {Infeasibility LNS};
\node[label, anchor=south west] at ([xshift=3pt]obj-box.north west) {Objective LNS};

% ----------- Arrows -----------
\draw[arrow] (initial.east) -- (reduce.west);
\draw[arrow] (var-fix1) to[out=-90,in=-180] (reduce);
\draw[arrow] (reduce.east) -- (improved-feas.west);
\draw[arrow] (improved-feas.east) -- (minimize.west);
\draw[arrow] (var-fix2) to[out=-90,in=-180] (minimize);
\draw[arrow] (minimize.east) -- (improved-qual.west);

% Feedback arrow
\draw[arrow] (improved-qual.south) -- ++(0,-1) -| (initial.south);

\end{tikzpicture}}
\caption{ACS Heuristic Workflow Diagram}
\label{fig:ACS_heu_workflow}
\end{figure}

\section{Feasibility-MIP (FMIP)}
In linear programming theory, it is well established that the feasibility problem can be addressed using the two-phase Simplex method, in which an auxiliary optimization problem is solved to obtain a feasible starting basis, and hence a feasible solution.
In a similar manner, the following auxiliary MIP problem, denoted as the Feasibility-MIP (FMIP), is formulated to identify a feasible starting solution:
\begin{equation}
\begin{cases}
\text{min} \quad & \sum_{i=0}^m \Delta_i^{+}+\Delta_i^{-} \\ \text{s.t.} \quad & Ax + I_m\Delta^+ - I_m\Delta^- =b\\ & x_i = \hat{x}_i, \; \forall i \in F\\ & l \le x \le u\\ & x_i \in \mathbb{Z}, \; \forall i \in \mathcal{I} \\ & \Delta^+ \ge 0, \Delta^- \ge 0 
\end{cases}
\end{equation}
Here, $I_m$ denotes an $m \times m$ identity matrix, while $\Delta^+$ and $\Delta^-$ are vectors in $R^m$ corresponding to the $m$ constraints. These are introduced as slack variables, and the objective is to minimize their sum. 
Analogous to the two-phase Simplex method, a vector $x$ is feasible for the original MIP if and only if it can be extended to a solution of value $0$ for the associated FMIP. Since solving an FMIP is as computationally demanding as solving the original problem, the neighborhoods are restricted by fixing a given subset $F$ of the integer variables to the values of an input vector $[\hat{x}, \Delta^+, \Delta^-]$. Because of the introduction of slack variables, the vector $\hat{x}$ is not required to be a feasible solution itself, but it must be integral and within the variable bounds to preserve the feasibility of the model. In this way, the FMIP guarantees that feasibility is preserved under any arbitrary variable-fixing scheme. Once a feasible solution is obtained, any LNS-based improving heuristic—such as RINS$^\text{\cite{RINS}}$, DINS$^\text{\cite{DINS}}$, or local branching$^\text{\cite{localBranching}}$—can then be applied to refine the solution.
\section{Optimality-MIP (OMIP)}
Rather than executing the FMIP until convergence to a feasible solution vector, the following auxiliary MIP problem, denoted as Optimality-MIP (OMIP), is designed to improve a partially feasible solution $[\hat{x}, \hat{\Delta}^+, \hat{\Delta}^-]$, which satisfies $\sum_{i=1}^m (\hat{\Delta}_i^+ + \hat{\Delta}_i^-) \neq 0$, with respect to the original objective $c^T x$:
\begin{equation}
\begin{cases}
\text{min} \quad & c^T x \\ \text{s.t.} \quad & Ax + I_m\Delta^+ - I_m\Delta^- = b\\ & \sum_{i=0}^m \Delta_i^{+}+\Delta_i^{-} \le \sum_{i=0}^m \hat\Delta_i^{+}+\hat\Delta_i^{-}\\ & x_i = \hat{x}_i, \; \forall i \in F\\ & l \le x \le u\\ & x_i \in \mathbb{Z},\; \forall i \in \mathcal{I} \\ & \Delta^+ \ge 0, \; \Delta^- \ge 0 
\end{cases}
\end{equation}
Analogous to the FMIP, the OMIP represents a reformulation of the original MIP model in which auxiliary slack variables are introduced for each constraint. This formulation enables the OMIP to enhance a solution even if it is not feasible for the original MIP. Moreover, to ensure that the optimal solution of the OMIP does not exceed the infeasibility of the input solution $\hat{x}$, an additional budget constraint is imposed, limiting the total slack to $\sum_{i=0}^m \hat\Delta_i^{+}+\hat\Delta_i^{-}$.

By iteratively solving subproblems of both auxiliary MIPs, the ACS heuristic is designed to converge—although convergence is not formally guaranteed—to a high-quality feasible solution. By construction, infeasibility decreases monotonically after each iteration. However, the quality of the solution with respect to the original objective function may fluctuate.

\section{Parallelization of ACS (PACS)}
The parallelization of ACS exploits parallelism by generating a diversified set of large neighborhood searches, which are solved simultaneously. Exploring multiple search neighborhoods in parallel is expected to increase the likelihood of identifying high-quality solutions.
Following this parallelization step, the improvements obtained in parallel must be combined efficiently. To this end, an additional search subproblem is generated in which variables with identical values across different solutions are fixed. Consequently, the recombination phase constitutes a crucial step in PACS: by merging the improvements achieved during the parallel phase, the subsequent phase can explore a newly diversified set of large neighborhood searches based on the recombined solution, thereby enhancing the probability of further improvements.
\begin{algorithm}[htbp]
\caption{Parallel Alternating Criteria Search (PACS)}\label{alg:PACS}
\begin{algorithmic}
\Function{FMIP\_LNS}{$MIP$, $F$, $\hat{x}$}
    \State \Return $\min\{\sum_i \Delta^+_i + \Delta^-_i \mid A x + I_m \Delta^+ - I_m \Delta^- = b, \; x_j = \hat{x}_j \; \forall j \in F, \; x_j \in \mathbb{Z} \; \forall j \in \mathcal{I}\}$
\EndFunction
\end{algorithmic}
\vspace{1em}
\begin{algorithmic}
\Function{OMIP\_LNS}{$MIP$, $F$, $\hat{x}$, $\hat{\Delta}$}
    \State \Return $\min\{c^T x \mid A x + I_m \Delta^+ - I_m \Delta^- = b, \; \sum_i^m \Delta^+_i + \Delta^-_i \leq \hat{\Delta}, \; x_j = \hat{x}_j \; \forall j \in F, \; x_j \in \mathbb{Z} \; \forall j \in \mathcal{I}\}$
\EndFunction
\end{algorithmic}
\vspace{1em}
\begin{algorithmic}[1]
\Require{Original $MIP$ formulation; PACS Execution time limit $TL_{PACS}$; Number of threads $T$; Initial solution parameter $\theta \in (0,100]$; Variable fixing parameter $\rho \in (0,1)$}
\Ensure{Feasible solution $\hat{x}$ if found}
\Function{PACS}{$MIP$, $TL_{PACS}$, $T$, $\theta$, $\rho$}
\State $[\hat{x}, \hat{\Delta}^+, \hat{\Delta}^-] \gets \Call{InitThetaSolution}{MIP,\theta,10^6}$
\While{\Call{TimeElapsed} $\le TL_{PACS}$ }
    \If{$\sum_i^m \hat\Delta_i^+ + \hat\Delta_i^- > 0$}
        \ForAll{threads $t_i:  i \in \{0,T-1\}$ \textbf{in parallel}}
            \State $F_{t_i} \gets \Call{RandomFixings}{MIP,\rho}$
            \State $[x^{t_i}, \Delta^{+t_i}, \Delta^{-t_i}] \gets \Call{FMIP\_LNS}{MIP,F_{t_i}, \hat{x}}$
        \EndFor
        \State $U \gets \{ j \in \mathcal{I} | x^{t_i}_j = x^{t_k}_j, \; 0 \leq i < k < T\}$
        \State $[\hat{x}, \hat{\Delta}^+, \hat{\Delta}^-] \gets \Call{FMIP\_LNS}{MIP,U, x^{t_0}}$
    \EndIf
    \State $\Delta^{UB} \gets \sum_i^m \hat{\Delta}_i^+ + \hat{\Delta}_i^-$
    \ForAll{threads $t_i:  i \in \{0,T-1\}$ \textbf{in parallel}}
            \State $F_{t_i} \gets \Call{RandomFixings}{MIP,\rho}$
            \State $[x^{t_i}, \Delta^{+t_i}, \Delta^{-t_i}] \gets \Call{OMIP\_LNS}{MIP,F_{t_i}, \hat{x}, \Delta^{UB}}$
    \EndFor
    \State $U \gets \{ j \in \mathcal{I} | x^{t_i}_j = x^{t_k}_j, \; 0 \leq i < k < T\}$
    \State $[\hat{x}, \hat{\Delta}^+, \hat{\Delta}^-] \gets \Call{OMIP\_LNS}{MIP,U, x^{t_0}, \Delta^{UB}}$
\EndWhile
\State \Return $[\hat{x}, \hat{\Delta}^+, \hat{\Delta}^-]$
\EndFunction
\end{algorithmic}
\end{algorithm}
The Algorithm \ref{alg:PACS} illustrates the overall workflow. In this process, each processor generates a set of randomized variable fixings and then solves the corresponding sub-MIP—either FMIP or OMIP—until the allotted time limit is reached.
Subsequently, the solutions are exchanged, and the set $U$, containing the indices of variables common across solutions, is constructed. The recombination MIP then consists of a subproblem, again associated with either FMIP or OMIP, in which the variables in $U$ are fixed.
The best solution obtained will be either the most feasible or the most optimal, depending on whether a recombination FMIP or OMIP is employed. Moreover, every solution used as input can be incorporated as a MIP start, as it remains feasible under any variable-fixing strategy.
Processor synchronization and memory communication are handled via the Message Passing Interface (MPI)$^\text{\cite{MPI}}$, owing to its efficient all-to-all collective communication primitives in distributed large-scale architectures.
To better illustrate the framework, Figure \ref{fig:PACS_heu_workflow} presents a schematic overview of the PACS heuristic, with an emphasis on its parallelization.
\begin{figure}[hbtp]
\centering
\resizebox{\columnwidth}{!}{
\begin{tikzpicture}[
    rect/.style={rectangle, draw=black, align=center, font=\footnotesize, fill=white},
    oval/.style={ellipse, draw=black, align=center, font=\footnotesize, fill=white},
    arrow/.style={->, >=Stealth},
    big-box/.style={rectangle, draw=black, dash pattern=on 5pt off 3pt,
                    inner sep=12pt, fill=gray!20, rounded corners=2pt},
    label/.style={font=\footnotesize\bfseries}
]

\node[rect] at (4,1) (initial) {Initial\\Solution};

\node[rect] at (-2,-2) (var_fix1) {Variable Fixing};
\node[rect] at (10,-2) (var_fixT) {Variable Fixing};
\node[oval] at (-1,-3.5) (reduce_infeas1) {Reduce \\ Infeasibility};
\node[oval] at (9,-3.5)  (reduce_infeasT) {Reduce \\ Infeasibility};

\node at (4,-3) (tmp){\large\textbf{\dots}};

\node[rect] at (-1,-6) (improved_feas1) {Improved\\Feasibility\\Solution $0$};
\node[rect] at (9,-6)  (improved_feasT) {Improved\\Feasibility\\Solution $T-1$};

\node[rect] at (1.5,-8.5) (var_fix_rFMIP) {Variable Fixing};
\node[oval] at (4,-10)  (infeas_rFMIP) {Reduce\\Infeasibility};
\node[rect] at (4,-12.5) (improved_rFMIP) {Improved\\Feasibility\\Solution};

\node[rect] at (-2,-15.5) (var_fix3) {Variable Fixing};
\node[rect] at (10,-15.5) (var_fixT2) {Variable Fixing};
\node[oval] at (-1,-17) (min_obj1) {Minimize\\Objective};
\node[oval] at (9,-17)  (min_objT) {Minimize\\Objective};

\node at (4,-16.5) (tmp2){\large\textbf{\dots}};

\node[rect] at (-1,-19.5) (improved_obj3) {Improved\\Quality\\Solution 1};
\node[rect] at (9,-19.5)  (improved_objT2) {Improved\\Quality\\Solution T};

\node[rect] at (1.5,-22) (var_fix_rOMIP) {Variable Fixing};
\node[oval] at (4,-23.5)  (min_obj_rOMIP) {Minimize\\Objective};
\node[rect] at (4,-26)  (improved_rOMIP) {Improved\\Quality\\Solution};

\begin{pgfonlayer}{background}

  \node[big-box, fit=(var_fix1)(reduce_infeas1)]  (infeas-box1) {};
  \node[big-box, fit=(var_fixT)(reduce_infeasT)]  (infeas-boxT) {};

  \node[big-box, fit=(var_fix_rFMIP)(infeas_rFMIP)] (rFMIP-box) {};

  \node[big-box, fit=(var_fix3)(min_obj1)]         (min_box_1) {};

  \node[big-box, fit=(var_fixT2)(min_objT)]        (min_box_T) {};

  \node[big-box, fit=(var_fix_rOMIP)(min_obj_rOMIP)] (rOMIP-box) {};
\end{pgfonlayer}

\node[label, anchor=south west] at ([xshift=3pt]infeas-box1.north west) {Infeasibility LNS $0$};

\node[label, anchor=south west] at ([xshift=3pt]infeas-boxT.north west) {Infeasibility LNS $T-1$};

\node[label, anchor=south west] at ([xshift=1pt]rFMIP-box.north west) {Recombination Inf. LNS};

\node[label, anchor=south west] at ([xshift=3pt]min_box_1.north west) {Objective LNS  $0$};
\node[label, anchor=south west] at ([xshift=3pt]min_box_T.north west) {Objective LNS $T-1$};

\node[label, anchor=south west] at ([xshift=1pt]rOMIP-box.north west) {Recombination Obj. LNS};

\draw[arrow] (var_fix1) -- (reduce_infeas1);
\draw[arrow] (initial) to[out=-90,in=75](reduce_infeas1);
\draw[arrow] (reduce_infeas1) -- (improved_feas1);


\draw[arrow] (var_fixT) -- (reduce_infeasT);
\draw[arrow] (initial) to[out=-90,in=115] (reduce_infeasT);
\draw[arrow] (reduce_infeasT) -- (improved_feasT);

\draw[arrow] (var_fix3) -- (min_obj1);
\draw[arrow] (min_obj1) -- (improved_obj3);
\draw[arrow] (improved_rFMIP) to[out=-90,in=80] (min_obj1);

\draw[arrow] (var_fixT2) -- (min_objT);
\draw[arrow] (min_objT) -- (improved_objT2);
\draw[arrow] (improved_rFMIP)  to[out=-90,in=110] (min_objT);

\draw[arrow] (improved_feas1) to[out=-90,in=90] (infeas_rFMIP);
\draw[arrow] (improved_feasT) to[out=-90,in=90] (infeas_rFMIP);
\draw[arrow] (var_fix_rFMIP) -- (infeas_rFMIP);
\draw[arrow] (infeas_rFMIP) -- (improved_rFMIP);

\draw[arrow] (improved_obj3)to[out=-90,in=90](min_obj_rOMIP);
\draw[arrow] (improved_objT2) to[out=-90,in=90] (min_obj_rOMIP);
\draw[arrow] (var_fix_rOMIP) -- (min_obj_rOMIP);
\draw[arrow] (min_obj_rOMIP) -- (improved_rOMIP);

\draw[arrow] (improved_rOMIP.west) -- (-6,-26) --(-6,1) -- (initial.west);

\end{tikzpicture}}
\caption{PACS Heuristic Workflow Diagram}\label{fig:PACS_heu_workflow}
\end{figure}

\section{Initialization of ACS}
As introduced earlier in this chapter, ACS only requires a starting vector that is integer feasible and within the variable bounds. However, a stronger starting point is a solution that is as feasible as possible with respect to the objective function of the FMIP.
The proposed algorithm provides a lightweight heuristic that seeks to minimize the infeasibility of the initial solution.
\begin{algorithm}
\caption{Starting vector heuristic}\label{alg:starting_vector}
\begin{algorithmic}
\Function{RELAXED\_FMIP}{$MIP$, $F$, $\hat{x}$}
    \State \Return $\min\{\sum_i \Delta_i^+ + \Delta_i^- \mid A x + I_m \Delta^+ - I_m \Delta^- = b, \; x_j = \hat{x}_j \;\; \forall j \in F\}$
\EndFunction
\end{algorithmic}
\vspace{1em}
\begin{algorithmic}[1]
\Require{Original $MIP$ formulation; Percentage of variables to fix $\theta \in (0,100]$; Fixed bound constant $c_b$}
\Ensure{Starting integer-feasible vector $\hat{x}$}
\Function{InitThetaSolution}{$MIP$, $\theta$, $c_b$}
\State $V \gets \text{sort}_\uparrow(\{x \in \mathcal{I}\}, (u_x-l_x))$
\State $F \gets \emptyset$
\State $\hat{x} \gets [+\infty, \ldots, +\infty] \in \bar{\mathbb{R}}^{n} $
\While{$\lnot \Call{IsIntegerFeasible}{\hat{x}} \land F \neq \mathcal{I}$}
    \State $\mathcal{K} \gets$ top $\theta \%$ of unfixed variables from $V$
    \For{$k \in \mathcal{K}$}
        \State $\hat{x}_k \gets \Call{RandomInteger}{\max(l_k, -c_b), \min(u_k, c_b)}$
    \EndFor
    \State $F \gets F \cup \mathcal{K}$
    \State $[x, \Delta^+, \Delta^-] \gets \Call{RELAXED\_FMIP}{MIP,F,\hat{x}}$
    \State $Q \gets \{i \;|\; x_i \in x,\; x_i \in \mathbb{Z},\; x_i \in \mathcal{I}\}$
    \State $\hat{x}_q \gets x_q, \; \forall q \in Q$
    \State $F \gets F \cup Q$
\EndWhile
\State \Return $\hat{x}$
\EndFunction
\end{algorithmic}
\end{algorithm}
The Algorithm \ref{alg:starting_vector} first sorts the list of integer variables in order of increasing bound range. It then fixes the top $\theta$\% of variables to random integer values within their respective bounds. The input parameter $\theta$ controls the trade-off between the difficulty of the LP relaxation and the quality of the resulting starting solution. In cases where the bounds are infinite, a constant value $c_b = 10^6$ is used to clamp the bounds.
The rationale behind the sorting step is to prioritize binary variables first, followed by the remaining integer variables.
Until all integer variables are fixed, the LP relaxation of the FMIP is solved to optimize the unfixed variables. Any variables that attain integer values in this process are then fixed.
Since at least $\theta$\% of the variables are fixed at each iteration, the algorithm is guaranteed to terminate after at most $\lceil 100 / \theta \rceil$ iterations.
\section{Variable Fixing Strategy}\label{sec:PACS_var_fix}
Selecting an appropriate variable fixing scheme is a challenging task: an overly restrictive strategy may fail to yield improvements, whereas an excessively loose strategy can lead to a search space that is too large to explore efficiently within a reasonable timespan.
The proposed algorithm constitutes a simple yet intuitive variable fixing method: it incorporates randomness to promote diversification and allows for controlling the number of variables to be fixed through an adjustable parameter.
\begin{algorithm}
\caption{Variable Fixing Selection Algorithm}\label{alg:variable_fixing}
\begin{algorithmic}[1]
\Require{Original $MIP$ formulation; Fraction of variables to fix $\rho \in (0,1)$}
\Ensure{Set of integer indices $F$}
\Function{RandomFixings}{$MIP$, $\rho$}
    \State $i \gets \Call{UniformFrom}{\mathcal{I}}$
    \State $F \gets \big[(i,i+1,\dots,i+\rho\cdot|\mathcal{I}| -1) \mod |\mathcal{I}|\big]$
    \State \Return $F$
\EndFunction
\end{algorithmic}
\end{algorithm}
In the Algorithm \ref{alg:variable_fixing}, the fixings are determined by selecting a random integer variable $x_i$ and fixing a consecutive sequence of integer variables starting from $x_i$ up to a cap determined by $\rho$, an input parameter that specifies the number of variables to be fixed.
The fixing is performed in a circular fashion: if the end of the set $\mathcal{I}$ is reached before the required number of variables are fixed, the algorithm continues from the beginning of $\mathcal{I}$.
The effectiveness of this strategy relies on the fact that, for many problems—such as network flow and routing—the variables are arranged consecutively, often defining a cohesive substructure within the problem.