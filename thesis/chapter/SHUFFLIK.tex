L’idea alla base dell’algoritmo ShuffLik è quella di scambiare i pesi degli archi aventi lo stesso vertice di partenza, per 
aumentare la navigabilità della rete. 
Di seguito, vengono esposti i principi teorici e 
le metriche per valutare l'efficacia di questo approccio. 

\section{Diverse navigability}
In molte reti sociali, l'aggiunta di archi è spesso un'operazione invasiva e non sempre possibile. 
Se si pensa, ad esempio, ai sistemi di raccomandazione (es. articoli suggeriti di Amazon) risulta evidente il fatto che il numero di elementi 
consigliabili è limitato. Per questo motivo, l'approccio di RePBubLik è inefficiente e quindi si dovrà considerare una nuova 
misura che chiameremo \emph{diverse navigability} che tiene in considerazione i valori di Bubble Radius di \emph{tutti} i vertici della rete.
\begin{definition}[Diverse navigability]
    Dato $S \subseteq V$, la diverse navigability $\xi(S)$ di $S$ è l'opposto del Bubble Radius medio dei vertici in $S$.
    \begin{equation}
        \xi(S)\doteq - {1\over{|S|}}\sum_{v\in S}{B_{G}^t(v)}
    \end{equation}
    Quando $S=V$, si parla di diverse navigability del grafo $G$; si denota con $\xi(G)$
\end{definition}

\section{Aumento della navigabilità mediante lo scambio delle probabilità di transizione}
L'idea alla base di ShuffLik è quella di aumentare la navigabilità di una rete scambiando tra loro i pesi 
di due archi appartenenti allo stesso vertice (es. pagina web).
Questo nella pratica è molto sensato: numerosi studi hanno dimostrato che la probabilità che un certo link venga cliccato è spesso collegata da fattori grafici 
quali posizione, colore o font. Scambiare, quindi, la posizione dei link all'interno della pagina permetterebbe alla rete di essere più fruibile e navigabile.
Per questo, si definisce l'insieme dei \emph{diversifying swaps} come l'insieme delle coppie di archi che risultano ragionevoli da scambiare, per aumentare 
la diverse navigability.
\begin{definition}[Diversifying swaps]
    Per $C \in \{R,B\}$, l'insieme $D_C$ dei diversifying swaps è l'insieme di coppie ordinate di archi, dove per ogni $(e,e')$ vale che:
    \begin{enumerate}
        \item $(e,e')=((v,w),(v,u))$ con $v,w \in C$ e $u \in \overline{C}_v$
        \item $M(e) > M(e')$
    \end{enumerate} 
\end{definition}
Sostituire il peso di $e$ con il peso $e'$ della coppia $(e,e') \in D_C$, permette di diminuire il Bubble Radius del vertice di partenza $v$ ,
aumentando così la diverse navigability $\xi(C_v)$ e, conseguentemente, la $\xi(G)$.
\\
Per quantificare il miglioramento apportato da questo swap, sarà necessaria una qualche misura di guadagno.
\begin{definition}[Guadagno sul BR di $u$ dato dallo swap di $e$ con $e'$]
    Per $C \in \{R,B\}, u\in C$ e $t' \le t$, il guadagno $\Gamma(G,u,(e,e'),t')$ sul Bubble Radius di $u$
    ottenuto dallo swap della probabilità di transizione di $(e,e')\in D_C$, è definito come
    \begin{equation}\label{SHU:gain}
        \Gamma(G,u,(e,e'),t')\doteq B_{G}^{t'}(u) - B_{G_{e,e'}}^{t'}(u)
    \end{equation}
    dove $G_{e,e'}$ è il grafo $G$ dopo aver scambiato i pesi tra $e$ ed $e'$.
\end{definition}
Chiaramente, il guadagno totale può essere ottenuto estendendo la definizione \ref{SHU:gain} all'intero \emph{diversifying swaps}.
\begin{definition}[Guadagno totale]
    Sia $\Sigma \subseteq D_{C}$ e $G_{\Sigma}$ il grafo ottenuto scambiando tra loro tutti i pesi delle coppie contenute 
    in $\Sigma$. Il guadagno totale di $\Sigma$ è definito
    \begin{equation}
        \mathbb{G}(G,\Sigma)\doteq {1\over{|C|}}\sum_{u\in C}{\Big(B_{G}^{t}(u) - B_{G_{\Sigma}}^{t}(u) \Big)}
    \end{equation}
\end{definition}
\subsection{Approssimazione del problema}
Risulta evidente che scambiare tra loro tutti gli archi contenuti in $D_C$ diventa un operazione onerosa e non ragionevole nella pratica.
Per questo, si assume che il numero di possibili swaps sia limitato ad un numero $k$.
\begin{problem}\label{problem:3}
    Dato un grafo $G$, un colore $C$, e un parametro $k$, trovare un set $\Sigma \subseteq D_C$ di dimensione $k$ che 
    massimizzi il guadagno $\mathbb{G}{(G,\Sigma)}$. 
\end{problem}
ShuffLik è l'algoritmo che approssima la soluzione del problema \ref{problem:3}.
\begin{theorem}[Approssimazione di ShuffLik]
    Sia $\Sigma \subseteq D_C$ l'output di ShuffLik e OPT la soluzione ottima al problema \ref{problem:3}. Allora
    \begin{equation}
        \mathbb{G}(G,OPT) \le \Bigg(2{t\over{r}}\gamma_{t-2}+1\Bigg)\Bigg(1+{1\over{e}}\Bigg)\mathbb{G}(G,\Sigma)
    \end{equation}
    dove $\gamma_t\doteq \max_{v\in V} F_{t'}(v)$ (\ref{eq:F})
\end{theorem}
Dunque, ShuffLik fornisce una \emph{approssimazione a fattore costante}, sotto l'assunzione che $\gamma_t$ 
sia una costante e che $r \ge t/2$
\section{ShuffLik: definizione intuitiva}
Dato il fatto che la funzione obiettivo (guadagno $\mathbb{G}$) è \emph{monotona} e \emph{sub-modulare}, la scelta
della coppia di archi da scambiare può essere effetuata in maniera greedy. La scelta greedy deve considerare la coppia $(e,e')$ che massimizza il guadagno.
Ma questa operazione non è per niente banale.\\ 
Verrà selezionata, quindi, la coppia $(e,e')$ che \emph{approssima} la scelta greedy.
Per far ciò, ShuffLik prediligerà la coppia $(e,e') \in D_C$, con vertice iniziale $v$, che massimizza 
la quantità $r^{t-2}(v,C)\times |M(e)-M(e')|$, dove $r^{t-2}(v,C)$ è il RWCC di $v$.
\section{ShuffLik: pseudocodice}
\begin{algorithm}[!h]
    \caption{ShuffLik}\label{alg:shufflik}
    \begin{algorithmic}
    \Require Grafo $G=(V,E)$, matrice di transizione $M_G$, colore $C \in \{R,B\}$, numero di swaps desiderati $k$.
    \Ensure L'insieme $\Sigma$ di $k$ coppie di archi che devono essere scambiati.
    \\
    \State $\Sigma \gets \emptyset$
    \For{$i=1 ,\dots, k$}
        \State $D_C \gets getDiversifyingSwaps(G,C,\Sigma)$
        \State $R \gets computeRWCentrality(C)$
        \State $(e,e') \gets \arg\max_{(e,e') \in D_C} R(v)\times (M_G(e)-M_G(e'))$
        \State $\Sigma \gets \Sigma \cup \{(e_i,e'_i)\}$
    \EndFor
    \State\Return $\Sigma$
    \end{algorithmic}
\end{algorithm}
L'algoritmo ShuffLik prende come input un grafo $G$, la matrice di transizione $M_G$, 
il numero $k$ di swap desiderati e un insieme di nodi di colore $C$. \\
Per prima cosa, viene creato l'insieme $\Sigma$ (inizialmente vuoto) che conterrà le coppie 
di archi da scambiare. Successivamente, per $k$ volte: si ottiene 
l'insieme diversifying swaps $D_C$, utilizzando la funzione \emph{getDiversifyingSwaps}.
Quest'ultima prende come parametri il grafo $G$, il colore $C$, l'insieme $\Sigma$ e ritorna il set
$D_C$ dei possibili swap del grafo $G_\Sigma$, ottenuto scambiando i pesi degli archi in $\Sigma$. 
Per determinare l'insieme $D_C$, la subroutine dovrà valutare Bubble Radius di tutti i vertici in $C$.
In seguito, si calcola il RWCC di ogni nodo in $C$, il quale viene salvato in un dizionario $R$. 
A questo punto, ShuffLik selezione la coppia $(e,e')$ associata al valore più alto di $R(v)\times |M_G(e)-M_G(e')|$,
con $v$ il vertice sorgente di $(e,e')$. Così facendo, si ottiene la coppia di archi $(e,e')$ da aggiungere all'insieme $\Sigma$.
Dopo le $k$ iterazioni, infatti, l'insieme $\Sigma$ sarà popolato da $k$ coppie di archi da scambiare.
\subsection{ShuffLik+}
L'algoritmo ShuffLik presuppone che lo scambio dei pesi abbia un costo fisso. 
Più generalmente, nel caso in cui il costo per effettuare lo swap tra i pesi di due archi non sia un valore fisso e ci sia un budget di costo
da rispettare, si utilizza un approccio simile a ShuffLik, ma con un funzione di costo $Q: E\times E \to \mathbb{R}$ e un budget $B \in \mathbb{R}^+$ da 
non superare. Questa versione modificata dell'algoritmo ShuffLik prende il nome di ShuffLik+.

