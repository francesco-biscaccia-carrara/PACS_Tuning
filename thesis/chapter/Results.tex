%intro
\section{Experimental Setup}
The experiments are designed to compare the PACS framework with the standalone IBM ILOG CPLEX Optimization Studio (version 22.1).  
The PACS framework is implemented in C++ for performance reasons, interfacing with the solver through the C API. The source code is available under a non-commercial MIT license at \url{https://github.com/francesco-biscaccia-carrara/PACS_Tuning}. 

All experiments were conducted on a cluster within the UniPD DEI Blade infrastructure, running Rocky Linux 8.10. Each node is equipped with an Intel(R) Xeon(R) E5-2623 v3 processor (4 cores, 3.00 GHz) and 16 GB of RAM. Although the infrastructure is cluster-based, the computational power of a single node is comparable to that of a general-purpose laptop, or even lower.  
For fairness in comparison, PACS executions use 4 logical threads, implemented as C++ standard threads, each running a CPLEX instance restricted to a single core. The baseline counterpart is a standalone CPLEX execution restricted to 4 cores.

\subsection{Dataset}
As anticipated in the previous sections, the benchmark for this comparison must consist of hard MIP instances. To this end, the set of hard instances from MIPLIB 2017$^\text{\cite{MIPLIB}}$ has been used as the test bed.\footnote{The instance \textit{tpl-tub-ss16} was excluded, as its execution was terminated due to insufficient computational resources.}  
While CPLEX directly processes each MIP instance, the PACS framework additionally requires a random seed in order to reproduce the same randomized choices across different runs. For this purpose, PACS was evaluated on each instance using the seeds $\{38472910, 56473829, 27384910, 91827364, 8374659\}$. This setup increases statistical reliability and can be considered representative of the algorithmâ€™s standard behavior.  
Consequently, for each instance, five independent PACS runs and one CPLEX run were executed.

\subsection{Metrics}
Both PACS and plain CPLEX terminate as soon as an a feasible solution is identified, subject to a global time limit of $5$ minutes.
Since the PACS framework was executed five times for each instance, the reported solution quality and computation time are given as the mean across all runs.
Moreover, if the majority of PACS executions for a given instance---at least three out of five seeds---fail to produce a solution, the instance is recorded as unsolved.
Instead of directly comparing the objective values of the solutions returned by the two approaches, the MIP gap metric$^\text{\cite{MIPGAP}}$ has been adopted. The MIP gap is defined as follows: given a solution $\hat{x}$ for a MIP with an optimal solution $x$, the primal gap $\gamma(\hat{x}) \in [0,1]$ is
\begin{equation}
\gamma(\hat{x}) =
\begin{cases}
0 & \text{if } |c^T x| = |c^T \hat{x}| = 0, \\
1 & \text{if } c^T x \cdot c^T \hat{x}< 0, \\
\frac{|c^T x-c^T \hat{x}|}{\max\{|c^T \hat{x}|, |c^T x|\}} & \text{otherwise}.
\end{cases}
\end{equation}
This metric captures the relative gap between an incumbent and the best-known solution, normalized to the interval $[0,1]$.  
Since the algorithms operate under a strict time limit, the metric must be extended accordingly. Given a time limit $t_{\max}$, the primal function $p:[0,t_{\max}] \to [0,1]$ is defined as:
\begin{equation}
p(\hat{x}) =
\begin{cases}
1 & \text{if no solution is found up to time $t$}, \\
\gamma(\hat{x}(t)) & \text{if $\hat{x}(t)$ is the incumbent at time $t$}.
\end{cases}
\end{equation}
For each test, two types of plots are produced to summarize and compare performance:
\begin{enumerate}
    \item \textbf{Success Rate vs. Computation Time:}  
    The $x$-axis represents elapsed time, and the $y$-axis reports the cumulative number of instances for which an incumbent was found. The closer a curve is to the top-left corner, the more efficient the algorithm.  
    \item \textbf{Success Rate vs. MIP Gap:}  
    The $x$-axis represents the MIP gap, and the $y$-axis reports the cumulative number of instances solved with a gap less than or equal to the given value. Consistently, curves closer to the top-left corner indicate better performance 
\end{enumerate}
To provide a more compact quantitative comparison, the integral of each curve has been computed and reported in a corresponding bar chart, one for each plot.

\subsection{Tolerance Parameters}
Because both algorithms involve floating-point computations and comparisons, PACS employs a set of tolerance parameters. In these experiments, the parameters were selected to be reasonable relative to the defaults used by CPLEX:
\begin{itemize}
    \item \textbf{Zero-tolerance parameter} $\epsilon$: values smaller than $\epsilon$ are treated as zero. In all tests, $\epsilon$ was set to $10^{-5}$.
    \item \textbf{Absolute maximum constraint violation}: the maximum permissible violation of any constraint under a candidate solution $\hat{x}$. In these tests, it was set equal to $\epsilon$, i.e., $10^{-5}$.
    \item \textbf{Absolute maximum integrality violation}: the maximum deviation allowed for variables constrained to take integer values. This tolerance was likewise set to $\epsilon = 10^{-5}$.
    \item \textbf{Relative objective error}: the maximum admissible relative error between the recomputed objective value $c^T \hat{x}$ and the value stored internally by PACS. This threshold was again set to $\epsilon = 10^{-5}$.  
\end{itemize}  
In the latter three cases, if the corresponding tolerance is exceeded, the algorithm terminates with an error and the run is recorded as unsolved.  

\section{Results}\label{sec:result}
This section presents the experimental evaluation and details the progressive tuning of PACS parameters. Each test builds upon the outcomes of the previous one, providing a stepwise refinement of the algorithm.

\subsection{Fixed $\rho$ Initialization Test}\label{sec:test_fix_rho}
The first experiment focuses on the choice of the parameter $\rho$ in the variable fixing strategy.  
In this experiment, PACS was employed with generalized fixing strategies under an architecture-agnostic parallelization scheme
The predefined values of $\rho$ considered are $\{.1, .25, .5, .75, .9\}$.  
It is worth noting that smaller values of $\rho$ leave greater freedom to the MIP solver.  

Since the PACS algorithm also requires the parameter $\theta$ for the initial solution construction strategy, it was fixed to $\theta = .25$ for this test.  

\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD/ACS_STD-SuccRate.pgf}}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.4\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD/ACS_STD-SuccRate_integrals.pgf}}
    \end{minipage}
    \caption{Success Rate vs. Computation Time for Fixed $\rho$ Initialization Test}
    \label{fig:PACS_STD_SuccRate}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD/ACS_STD-MIPGapPlot.pgf}}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.4\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD/ACS_STD-MIPGapPlot_integrals.pgf}}
    \end{minipage}
    \caption{Success Rate vs. MIP Gap for Fixed $\rho$ Initialization Test}
    \label{fig:PACS_STD_MGAP}
\end{figure}
From Figure \ref{fig:PACS_STD_SuccRate}, it is evident that standalone CPLEX consistently outperforms PACS in terms of success rate across all values of $\rho$.  
However, Figure \ref{fig:PACS_STD_MGAP} reveals a different picture: PACS with $\rho = .1$ outperforms all other settings of $\rho$, and even surpasses CPLEX in terms of solution quality, providing higher-quality solutions approximately $1.72\times$ more frequently than the solver alone.
This result may be attributed to the fact that greater freedom allows CPLEX to optimize more effectively, whereas PACS primarily benefits from enhanced diversification through its parallelization strategy.

Based on these observations, the baseline PACS configuration under the static fixing scenario is set to $\theta = .25$ and $\rho = .1$.

\subsection{Dynamic $\rho$ Adjustment Test}\label{sec:test_dyn_rho}
This experiment investigates the dynamic adjustment strategy\footnote{In the plots, the PACS algorithm with dynamically adjusted $\rho$ is denoted as DACS for brevity.} for the variable fixing parameter $\rho$, as introduced in Section \ref{sec:dyn_var_fix}. Although PACS requires an initial $\rho$ value, it is automatically updated during execution. In this test, the candidate values for $\rho$ are ${.1, .25, .5}$, while the starting solution parameter $\theta$ is set to $.25$, consistent with the previous experiment.
\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_DYN/PACS_DYN-MIPSuccRatePlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_DYN/PACS_DYN-MIPSuccRatePlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. Computation Time for Dynamic $\rho$ Adjustment Test}
\label{fig:PACS_DYN_SuccRate}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_DYN/PACS_DYN-MIPGapPlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_DYN/PACS_DYN-MIPGapPlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. MIP Gap Plot for Dynamic $\rho$ Adjustment Test}
\label{fig:PACS_DYN_MGAP}
\end{figure}

As in the static case, Figure \ref{fig:PACS_DYN_SuccRate} shows that CPLEX consistently outperforms PACS in terms of success rate. However, Figure \ref{fig:PACS_DYN_MGAP} demonstrates that dynamic adjustment of $\rho$ improves solution quality: selecting $\rho = .1$ produces higher-quality solutions roughly $1.73\times$ more frequently than CPLEX alone.

The key observation from this experiment is that, unlike the fixed $\rho$ strategyâ€”where the choice of $\rho$ significantly affects PACS performanceâ€”the dynamic adjustment greatly reduces sensitivity to the initial parameter. Regardless of the starting $\rho$, PACS achieves comparable results in both success rate and solution quality, providing consistently reliable outcomes.

Based on these results, the baseline PACS configuration under the dynamic fixing scenario is set to $\theta = .25$ and initial $\rho = .1$.

\subsection{Fixed vs. Dynamically Adjusted $\rho$ Test}\label{sec:test_fixvsdyn_rho}
This experiment compares the fixed and dynamically adjusted strategies for selecting the variable fixing parameter $\rho$, aiming to identify the most effective approach for the final PACS algorithm. Since $\theta$ is consistent across the previous experiments, a direct comparison is possible.

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD_VS_DYN/PACS_STD_DYN-SuccRate.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD_VS_DYN/PACS_STD_DYN-SuccRate_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. Computation Time for Fixed vs. Dynamically Adjusted $\rho$ Test}
\label{fig:PACS_STD_DYN_SuccRate}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD_VS_DYN/PACS_STD_DYN-MIPGapPlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_STD_VS_DYN/PACS_STD_DYN-MIPGapPlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. MIP Gap Plot for Fixed vs. Dynamically Adjusted $\rho$ Test}
\label{fig:PACS_STD_DYN_MGAP}
\end{figure}

As evident from Figures \ref{fig:PACS_STD_DYN_SuccRate} and \ref{fig:PACS_STD_DYN_MGAP}, there is no significant difference in performance between the two strategies, both in terms of success rate and solution quality.

Considering the results from the previous experiment, the dynamic adjustment strategy for $\rho$ is preferred due to its reduced sensitivity to the initial parameter choice. Consequently, the final PACS framework adopts dynamic variable fixing with an initial $\rho = .1$ and $\theta = .25$.

\subsection{Initial Solution Construction Test}\label{sec:test_init_sol}
This experiment evaluates different strategies for constructing the initial solution, with the dual objectives of identifying the most effective parameter settings and, if possible, reducing parameter dependence. Specifically, the initialization strategy described in Section \ref{sec:gen_fixing} is analyzed with $\theta \in \{.25, 1\}$. The choice $\theta = .25$ encourages the algorithm to produce solutions of higher quality with respect to the original MIP objective, whereas $\theta = 1$ corresponds to constructing a solution by randomly fixing variables within their bounds. These two strategies are compared with the parameter-free approach introduced in Section \ref{sec:init_sol_maxFeas}.  
\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_IN_SOL/PACS_InitSol-SuccRate.pgf}}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.4\columnwidth} 
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_IN_SOL/PACS_InitSol-SuccRate_integrals.pgf}}
    \end{minipage}
    \caption{Success Rate vs. Computation Time for Initial Solution Construction Test}
    \label{fig:PACS_InitSol_SuccRate}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_IN_SOL/PACS_InitSol-MIPGapPlot.pgf}}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.4\columnwidth}
        \centering
        \resizebox{\linewidth}{!}{\input{chapter/img/PACS_IN_SOL/PACS_InitSol-MIPGapPlot_integrals.pgf}}
    \end{minipage}
    \caption{Success Rate vs. MIP Gap Plot for Initial Solution Construction Test}
    \label{fig:PACS_InitSol_MGAP}
\end{figure}
Figures \ref{fig:PACS_InitSol_SuccRate} and \ref{fig:PACS_InitSol_MGAP} indicate that overall performance is broadly comparable across all strategies. However, a closer inspection of the integral values reveals that the parameter-free strategy achieves the best results: 173.66 vs.\ 169.98 in terms of success rate, and 33.63 vs.\ 33.40 in terms of MIP gap integrals (MaxFeas vs. DACS, $\theta=.25$). Moreover, since the parameter-free approach eliminates the need to tune $\theta$, it represents a more robust and practical choice.

Consequently, based on this test, the best configuration of PACS employs a variable fixing strategy with dynamic adjustment of $\rho$ initialized at $\rho = .1$, combined with a parameter-free initial solution construction strategy that maximizes feasibility.

\subsection{Slack Upper Bound Enforcement Test}\label{sec:test_slack_UB}
In this experiment, the PACS algorithmâ€”tuned with the best strategies and parameters identified in the previous testsâ€”was evaluated to assess the effectiveness of the slack upper bound enforcement described in Section \ref{sec:slack_UB_BDG_constr}.

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_FIX_UB/PACS_FixSlackUB-SuccRatePlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_FIX_UB/PACS_FixSlackUB-SuccRatePlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. Computation Time for Slack Upper Bound Enforcement Test}
\label{fig:PACS_FixSlack_SuccRate}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_FIX_UB/PACS_FixSlackUB-MIPGapPlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_FIX_UB/PACS_FixSlackUB-MIPGapPlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. MIP Gap for Slack Upper Bound Enforcement Test}
\label{fig:PACS_FixSlack_MGAP}
\end{figure}

As shown in Figure \ref{fig:PACS_FixSlack_SuccRate}, this strategy narrows the gap between PACS and standalone CPLEX in terms of success rate. It is worth noting, however, that CPLEX solves around 60\% of the instances within the very first seconds, whereas PACS requires between 75 and 125 seconds to reach the same level of solved instances.

On the other hand, Figure \ref{fig:PACS_FixSlack_MGAP} indicates that this modification leads to a noticeable improvement in solution quality. Compared with the previously tuned PACS configuration, the enforced slack upper bound yields consistently better-quality solutions.

Therefore, the final PACS configuration integrates slack upper bound enforcement, as it enhances both efficiency and solution quality.

\subsection{Budget Constraint Removal Test}\label{sec:test_bdg_constr}
This experiment evaluates the impact of removing the budget constraint from the OMIP formulation. Intuitively, since the slack upper bound enforcement already fulfills the role of the budget constraint, its explicit inclusion should be unnecessary and potentially redundant.

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_BDG_CONSTR/ACS_BudgetCnstr-SuccRatePlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_BDG_CONSTR/ACS_BudgetCnstr-SuccRatePlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. Computation Time for Budget Constraint Removal Test}
\label{fig:PACS_BDGRem_SuccRate}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_BDG_CONSTR/ACS_BudgetCnstr-MIPGapPlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_BDG_CONSTR/ACS_BudgetCnstr-MIPGapPlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. MIP Gap for Budget Constraint Removal Test}
\label{fig:PACS_BDGRem_MGAP}
\end{figure}

As shown in Figures \ref{fig:PACS_BDGRem_SuccRate} and \ref{fig:PACS_BDGRem_MGAP}, removing the budget constraint slightly improves both success rate and solution quality. Beyond this performance gain, the simplification also reduces model complexity.

Therefore, the budget constraint is omitted in the final PACS framework, as its enforcement through slack upper bounds proves both sufficient and more efficient.

\subsection{WalkMIP Strategy Test}\label{sec:test_walkMIP}
The final experiment evaluates the performance of the WalkMIP strategy, a more sophisticated variable fixing approach compared to the original PACS method. The key parameter here is the probability $p$, which governs the likelihood of selecting a minimum-damage move rather than a random move. In practice, higher values of $p$ increase the chance of random moves being chosen. To investigate this effect, $p$ was tested with values $\{.6, .7, .8\}$.
\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_WALKMIP/PACS_WalkMIP-SuccRatePlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_WALKMIP/PACS_WalkMIP-SuccRatePlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. Computation Time for WalkMIP Strategy Test}
\label{fig:PACS_WalkMIP_SuccRate}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.6\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_WALKMIP/PACS_WalkMIP-MIPGapPlot.pgf}}
\end{minipage}%
\hfill
\begin{minipage}{0.4\columnwidth}
\centering
\resizebox{\linewidth}{!}{\input{chapter/img/PACS_WALKMIP/PACS_WalkMIP-MIPGapPlot_integrals.pgf}}
\end{minipage}
\caption{Success Rate vs. MIP Gap for WalkMIP Strategy Test}
\label{fig:PACS_WalkMIP_MGAP}
\end{figure}

As shown in Figures \ref{fig:PACS_WalkMIP_SuccRate} and \ref{fig:PACS_WalkMIP_MGAP}, the simpler and more direct variable fixing strategy consistently outperforms WalkMIP in both success rate and solution quality.

For this reason, WalkMIP was not included in the final PACS framework. The final configuration of PACS therefore incorporates all modifications validated up to the budget constraint removal test, with parameters set as follows: dynamic adjustment of $\rho$, initialized at $\rho=.1$, parameter-free initial solution construction, slack upper bound enforcement, and removal of the budget constraint.

